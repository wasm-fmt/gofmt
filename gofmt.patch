diff --git a/gofmt.js b/gofmt.js
index 8021b44..f7bfc3f 100644
--- a/gofmt.js
+++ b/gofmt.js
@@ -3,136 +3,10 @@
 // license that can be found in the LICENSE file.
 //
 // This file has been modified for use by the TinyGo compiler.
-
-(() => {
-	// Map multiple JavaScript environments to a single common API,
-	// preferring web standards over Node.js API.
-	//
-	// Environments considered:
-	// - Browsers
-	// - Node.js
-	// - Electron
-	// - Parcel
-
-	if (typeof global !== "undefined") {
-		// global already exists
-	} else if (typeof window !== "undefined") {
-		window.global = window;
-	} else if (typeof self !== "undefined") {
-		self.global = self;
-	} else {
-		throw new Error("cannot export Go (neither global, window nor self is defined)");
-	}
-
-	if (!global.require && typeof require !== "undefined") {
-		global.require = require;
-	}
-
-	if (!global.fs && global.require) {
-		global.fs = require("fs");
-	}
-
-	const enosys = () => {
-		const err = new Error("not implemented");
-		err.code = "ENOSYS";
-		return err;
-	};
-
-	if (!global.fs) {
-		let outputBuf = "";
-		global.fs = {
-			constants: { O_WRONLY: -1, O_RDWR: -1, O_CREAT: -1, O_TRUNC: -1, O_APPEND: -1, O_EXCL: -1 }, // unused
-			writeSync(fd, buf) {
-				outputBuf += decoder.decode(buf);
-				const nl = outputBuf.lastIndexOf("\n");
-				if (nl != -1) {
-					console.log(outputBuf.substr(0, nl));
-					outputBuf = outputBuf.substr(nl + 1);
-				}
-				return buf.length;
-			},
-			write(fd, buf, offset, length, position, callback) {
-				if (offset !== 0 || length !== buf.length || position !== null) {
-					callback(enosys());
-					return;
-				}
-				const n = this.writeSync(fd, buf);
-				callback(null, n);
-			},
-			chmod(path, mode, callback) { callback(enosys()); },
-			chown(path, uid, gid, callback) { callback(enosys()); },
-			close(fd, callback) { callback(enosys()); },
-			fchmod(fd, mode, callback) { callback(enosys()); },
-			fchown(fd, uid, gid, callback) { callback(enosys()); },
-			fstat(fd, callback) { callback(enosys()); },
-			fsync(fd, callback) { callback(null); },
-			ftruncate(fd, length, callback) { callback(enosys()); },
-			lchown(path, uid, gid, callback) { callback(enosys()); },
-			link(path, link, callback) { callback(enosys()); },
-			lstat(path, callback) { callback(enosys()); },
-			mkdir(path, perm, callback) { callback(enosys()); },
-			open(path, flags, mode, callback) { callback(enosys()); },
-			read(fd, buffer, offset, length, position, callback) { callback(enosys()); },
-			readdir(path, callback) { callback(enosys()); },
-			readlink(path, callback) { callback(enosys()); },
-			rename(from, to, callback) { callback(enosys()); },
-			rmdir(path, callback) { callback(enosys()); },
-			stat(path, callback) { callback(enosys()); },
-			symlink(path, link, callback) { callback(enosys()); },
-			truncate(path, length, callback) { callback(enosys()); },
-			unlink(path, callback) { callback(enosys()); },
-			utimes(path, atime, mtime, callback) { callback(enosys()); },
-		};
-	}
-
-	if (!global.process) {
-		global.process = {
-			getuid() { return -1; },
-			getgid() { return -1; },
-			geteuid() { return -1; },
-			getegid() { return -1; },
-			getgroups() { throw enosys(); },
-			pid: -1,
-			ppid: -1,
-			umask() { throw enosys(); },
-			cwd() { throw enosys(); },
-			chdir() { throw enosys(); },
-		}
-	}
-
-	if (!global.crypto) {
-		const nodeCrypto = require("crypto");
-		global.crypto = {
-			getRandomValues(b) {
-				nodeCrypto.randomFillSync(b);
-			},
-		};
-	}
-
-	if (!global.performance) {
-		global.performance = {
-			now() {
-				const [sec, nsec] = process.hrtime();
-				return sec * 1000 + nsec / 1000000;
-			},
-		};
-	}
-
-	if (!global.TextEncoder) {
-		global.TextEncoder = require("util").TextEncoder;
-	}
-
-	if (!global.TextDecoder) {
-		global.TextDecoder = require("util").TextDecoder;
-	}
-
-	// End of polyfills for common API.
-
 	const encoder = new TextEncoder("utf-8");
 	const decoder = new TextDecoder("utf-8");
-	var logLine = [];
 
-	global.Go = class {
+	class Go {
 		constructor() {
 			this._callbackTimeouts = new Map();
 			this._nextCallbackTimeoutID = 1;
@@ -249,50 +123,12 @@
 			this.importObject = {
 				wasi_snapshot_preview1: {
 					// https://github.com/WebAssembly/WASI/blob/main/phases/snapshot/docs.md#fd_write
-					fd_write: function(fd, iovs_ptr, iovs_len, nwritten_ptr) {
-						let nwritten = 0;
-						if (fd == 1) {
-							for (let iovs_i=0; iovs_i<iovs_len;iovs_i++) {
-								let iov_ptr = iovs_ptr+iovs_i*8; // assuming wasm32
-								let ptr = mem().getUint32(iov_ptr + 0, true);
-								let len = mem().getUint32(iov_ptr + 4, true);
-								nwritten += len;
-								for (let i=0; i<len; i++) {
-									let c = mem().getUint8(ptr+i);
-									if (c == 13) { // CR
-										// ignore
-									} else if (c == 10) { // LF
-										// write line
-										let line = decoder.decode(new Uint8Array(logLine));
-										logLine = [];
-										console.log(line);
-									} else {
-										logLine.push(c);
-									}
-								}
-							}
-						} else {
-							console.error('invalid file descriptor:', fd);
-						}
-						mem().setUint32(nwritten_ptr, nwritten, true);
-						return 0;
-					},
-					fd_close: () => 0,      // dummy
-					fd_fdstat_get: () => 0, // dummy
-					fd_seek: () => 0,       // dummy
-					"proc_exit": (code) => {
-						if (global.process) {
-							// Node.js
-							process.exit(code);
-						} else {
-							// Can't exit in a browser.
-							throw 'trying to exit with code ' + code;
-						}
-					},
-					random_get: (bufPtr, bufLen) => {
-						crypto.getRandomValues(loadSlice(bufPtr, bufLen));
-						return 0;
-					},
+					fd_write() {},
+					fd_close() {},
+					fd_fdstat_get() {},
+					fd_seek() {},
+					proc_exit() {},
+					random_get() {}
 				},
 				env: {
 					// func ticks() float64
@@ -307,10 +143,15 @@
 					},
 
 					// func finalizeRef(v ref)
-					"syscall/js.finalizeRef": (sp) => {
-						// Note: TinyGo does not support finalizers so this should never be
-						// called.
-						console.error('syscall/js.finalizeRef not implemented');
+					"syscall/js.finalizeRef": (v_addr) => {
+						const id = mem().getUint32(v_addr, true);
+						this._goRefCounts[id]--;
+						if (this._goRefCounts[id] === 0) {
+							const v = this._values[id];
+							this._values[id] = null;
+							this._ids.delete(v);
+							this._idPool.push(id);
+						}
 					},
 
 					// func stringVal(value string) ref
@@ -464,7 +305,12 @@
 				null,
 				true,
 				false,
-				global,
+				// fake global
+				{
+					set format(fn){ instance.format = fn; },
+					Array,
+					Object,
+				},
 				this,
 			];
 			this._goRefCounts = []; // number of references that Go has to a JS value, indexed by reference id
@@ -472,8 +318,6 @@
 			this._idPool = [];      // unused ids that have been garbage collected
 			this.exited = false;    // whether the Go program has exited
 
-			const mem = new DataView(this._inst.exports.memory.buffer)
-
 			while (true) {
 				const callbackPromise = new Promise((resolve) => {
 					this._resolveCallbackPromise = () => {
@@ -511,25 +355,72 @@
 			};
 		}
 	}
-
-	if (
-		global.require &&
-		global.require.main === module &&
-		global.process &&
-		global.process.versions &&
-		!global.process.versions.electron
-	) {
-		if (process.argv.length != 3) {
-			console.error("usage: go_js_wasm_exec [wasm binary] [arguments]");
-			process.exit(1);
-		}
-
-		const go = new Go();
-		WebAssembly.instantiate(fs.readFileSync(process.argv[2]), go.importObject).then((result) => {
-			return go.run(result.instance);
-		}).catch((err) => {
-			console.error(err);
-			process.exit(1);
-		});
-	}
-})();
+/**
+ * ================== End of wasm_exec.js ==================
+ */
+/**/let wasm;
+/**/export default async function init(input) {
+/**/	if (wasm) {
+/**/		await wasm;
+/**/		return;
+/**/	}
+/**/	const go = new Go();
+/**/	wasm = load(input, go.importObject);
+/**/	wasm = await wasm;
+/**/	go.run(wasm.instance);
+/**/}
+/**/
+/**/async function load(module, importObject) {
+/**/	switch (typeof module) {
+/**/		case "undefined":
+/**/			module = "gofmt.wasm";
+/**/		case "string":
+/**/			module = new URL(module, import.meta.url);
+/**/	}
+/**/	if (module instanceof URL || module instanceof Request) {
+/**/		if (
+/**/			typeof __webpack_require__ !== "function" &&
+/**/			module.protocol === "file:"
+/**/		) {
+/**/			const fs = await import("node:fs/promises");
+/**/			module = await fs.readFile(module);
+/**/		} else {
+/**/			module = await fetch(module);
+/**/		}
+/**/	}
+/**/	if (module instanceof Response) {
+/**/		if ("instantiateStreaming" in WebAssembly) {
+/**/			try {
+/**/				return await WebAssembly.instantiateStreaming(
+/**/					module,
+/**/					importObject
+/**/				);
+/**/			} catch (e) {
+/**/				if (module.headers.get("Content-Type") != "application/wasm") {
+/**/					console.warn(
+/**/						"`WebAssembly.instantiateStreaming` failed because your server does not serve wasm with `application/wasm` MIME type. Falling back to `WebAssembly.instantiate` which is slower. Original error:\n",
+/**/						e
+/**/					);
+/**/				} else {
+/**/					throw e;
+/**/				}
+/**/			}
+/**/		}
+/**/		const bytes = await module.arrayBuffer();
+/**/		return await WebAssembly.instantiate(bytes, importObject);
+/**/	}
+/**/	const instance = await WebAssembly.instantiate(module, importObject);
+/**/	if (instance instanceof WebAssembly.Instance) {
+/**/		return { instance, module };
+/**/	}
+/**/	return instance;
+/**/}
+/**/
+/**/export function format(input) {
+/**/	const [err, result] = wasm.instance.format(input);
+/**/	if (err) {
+/**/		throw new Error(result);
+/**/	}
+/**/	return result;
+/**/}
+/**/
